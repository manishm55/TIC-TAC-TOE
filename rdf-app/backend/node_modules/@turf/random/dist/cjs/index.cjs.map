{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-random/dist/cjs/index.cjs","../../index.ts"],"names":[],"mappings":"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","file":"/home/runner/work/turf/turf/packages/turf-random/dist/cjs/index.cjs","sourcesContent":[null,"import {\n  BBox,\n  FeatureCollection,\n  LineString,\n  Point,\n  Polygon,\n  Position,\n} from \"geojson\";\nimport {\n  featureCollection,\n  isNumber,\n  isObject,\n  lineString,\n  point,\n  polygon,\n  validateBBox,\n} from \"@turf/helpers\";\n\n/**\n * Returns a random position within a {@link BBox|bounding box}.\n *\n * @function\n * @param {BBox} [bbox=[-180, -90, 180, 90]] a bounding box inside of which positions are placed.\n * @returns {Position} Position [longitude, latitude]\n * @throws {Error} if bbox is invalid\n * @example\n * var position = turf.randomPosition([-180, -90, 180, 90])\n * // => position\n */\nfunction randomPosition(bbox?: BBox | { bbox: BBox }): Position {\n  checkBBox(bbox);\n  return randomPositionUnchecked(bbox);\n}\n\n// does not check bbox for validity, that is handled by the exported functions\nfunction randomPositionUnchecked(bbox?: BBox | { bbox: BBox }): Position {\n  if (Array.isArray(bbox)) {\n    return coordInBBox(bbox);\n  }\n  if (bbox && bbox.bbox) {\n    return coordInBBox(bbox.bbox);\n  }\n  return [lon(), lat()];\n}\n\nfunction checkBBox(bbox?: BBox | { bbox: BBox }) {\n  if (bbox == null) {\n    return;\n  } else if (Array.isArray(bbox)) {\n    validateBBox(bbox);\n  } else if (bbox.bbox != null) {\n    validateBBox(bbox.bbox);\n  }\n}\n\n/**\n * Returns a random {@link point}.\n *\n * @function\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {BBox} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @returns {FeatureCollection<Point>} GeoJSON FeatureCollection of points\n * @throws {Error} if bbox is invalid\n * @example\n * var points = turf.randomPoint(25, {bbox: [-180, -90, 180, 90]})\n * // => points\n */\nfunction randomPoint(\n  count?: number,\n  options: {\n    bbox?: BBox;\n  } = {}\n): FeatureCollection<Point, any> {\n  checkBBox(options.bbox);\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    features.push(point(randomPositionUnchecked(options.bbox)));\n  }\n  return featureCollection(features);\n}\n\n/**\n * Returns a random {@link polygon}.\n *\n * @function\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {BBox} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_radial_length=10] is the maximum number of decimal degrees latitude or longitude that a\n * vertex can reach out of the center of the Polygon.\n * @returns {FeatureCollection<Polygon>} GeoJSON FeatureCollection of polygons\n * @throws {Error} if bbox is invalid\n * @example\n * var polygons = turf.randomPolygon(25, {bbox: [-180, -90, 180, 90]})\n * // => polygons\n */\nfunction randomPolygon(\n  count?: number,\n  options: {\n    bbox?: BBox;\n    num_vertices?: number;\n    max_radial_length?: number;\n  } = {}\n): FeatureCollection<Polygon, any> {\n  checkBBox(options.bbox);\n\n  // Default param\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n  if (options.bbox === undefined || options.bbox === null) {\n    options.bbox = [-180, -90, 180, 90];\n  }\n  if (!isNumber(options.num_vertices) || options.num_vertices === undefined) {\n    options.num_vertices = 10;\n  }\n  if (\n    !isNumber(options.max_radial_length) ||\n    options.max_radial_length === undefined\n  ) {\n    options.max_radial_length = 10;\n  }\n\n  const bboxWidth = Math.abs(options.bbox[0] - options.bbox[2]);\n  const bboxHeight = Math.abs(options.bbox[1] - options.bbox[3]);\n\n  const maxRadius = Math.min(bboxWidth / 2, bboxHeight / 2);\n\n  if (options.max_radial_length > maxRadius) {\n    throw new Error(\"max_radial_length is greater than the radius of the bbox\");\n  }\n\n  // Create a padded bbox to avoid the polygons to be too close to the border\n  const paddedBbox = [\n    options.bbox[0] + options.max_radial_length,\n    options.bbox[1] + options.max_radial_length,\n    options.bbox[2] - options.max_radial_length,\n    options.bbox[3] - options.max_radial_length,\n  ] as BBox;\n\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    let vertices: number[][] = [];\n    const circleOffsets = [...Array(options.num_vertices + 1)].map(Math.random);\n\n    // Sum Offsets\n    circleOffsets.forEach((cur, index, arr) => {\n      arr[index] = index > 0 ? cur + arr[index - 1] : cur;\n    });\n\n    // scaleOffsets\n    circleOffsets.forEach((cur) => {\n      cur = (cur * 2 * Math.PI) / circleOffsets[circleOffsets.length - 1];\n      const radialScaler = Math.random();\n      vertices.push([\n        radialScaler * (options.max_radial_length || 10) * Math.sin(cur),\n        radialScaler * (options.max_radial_length || 10) * Math.cos(cur),\n      ]);\n    });\n    vertices[vertices.length - 1] = vertices[0]; // close the ring\n\n    // center the polygon around something\n    vertices = vertices\n      .reverse() // Make counter-clockwise to adhere to right hand rule.\n      .map(vertexToCoordinate(randomPositionUnchecked(paddedBbox)));\n    features.push(polygon([vertices]));\n  }\n  return featureCollection(features);\n}\n\n/**\n * Returns a random {@link LineString}.\n *\n * @function\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {BBox} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_length=0.0001] is the maximum number of decimal degrees that a\n * vertex can be from its predecessor\n * @param {number} [options.max_rotation=Math.PI / 8] is the maximum number of radians that a\n * line segment can turn from the previous segment.\n * @returns {FeatureCollection<LineString>} GeoJSON FeatureCollection of linestrings\n * @throws {Error} if bbox is invalid\n * @example\n * var lineStrings = turf.randomLineString(25, {bbox: [-180, -90, 180, 90]})\n * // => lineStrings\n */\nfunction randomLineString(\n  count?: number,\n  options: {\n    bbox?: BBox;\n    num_vertices?: number;\n    max_length?: number;\n    max_rotation?: number;\n  } = {}\n): FeatureCollection<LineString, any> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const bbox = options.bbox;\n  checkBBox(bbox);\n  let num_vertices = options.num_vertices;\n  let max_length = options.max_length;\n  let max_rotation = options.max_rotation;\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n\n  // Default parameters\n  if (\n    !isNumber(num_vertices) ||\n    num_vertices === undefined ||\n    num_vertices < 2\n  ) {\n    num_vertices = 10;\n  }\n  if (!isNumber(max_length) || max_length === undefined) {\n    max_length = 0.0001;\n  }\n  if (!isNumber(max_rotation) || max_rotation === undefined) {\n    max_rotation = Math.PI / 8;\n  }\n\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    const startingPoint = randomPositionUnchecked(bbox);\n    const vertices = [startingPoint];\n    for (let j = 0; j < num_vertices - 1; j++) {\n      const priorAngle =\n        j === 0\n          ? Math.random() * 2 * Math.PI\n          : Math.tan(\n              (vertices[j][1] - vertices[j - 1][1]) /\n                (vertices[j][0] - vertices[j - 1][0])\n            );\n      const angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;\n      const distance = Math.random() * max_length;\n      vertices.push([\n        vertices[j][0] + distance * Math.cos(angle),\n        vertices[j][1] + distance * Math.sin(angle),\n      ]);\n    }\n    features.push(lineString(vertices));\n  }\n\n  return featureCollection(features);\n}\n\nfunction vertexToCoordinate(hub: number[]) {\n  return (cur: number[]) => {\n    return [cur[0] + hub[0], cur[1] + hub[1]];\n  };\n}\n\nfunction rnd() {\n  return Math.random() - 0.5;\n}\nfunction lon() {\n  return rnd() * 360;\n}\nfunction lat() {\n  return rnd() * 180;\n}\n\nfunction coordInBBox(bbox: BBox) {\n  return [\n    Math.random() * (bbox[2] - bbox[0]) + bbox[0],\n    Math.random() * (bbox[3] - bbox[1]) + bbox[1],\n  ];\n}\n\nexport { randomPosition, randomPoint, randomPolygon, randomLineString };\n"]}