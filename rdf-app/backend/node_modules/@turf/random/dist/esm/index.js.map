{"version":3,"sources":["../../index.ts"],"sourcesContent":["import {\n  BBox,\n  FeatureCollection,\n  LineString,\n  Point,\n  Polygon,\n  Position,\n} from \"geojson\";\nimport {\n  featureCollection,\n  isNumber,\n  isObject,\n  lineString,\n  point,\n  polygon,\n  validateBBox,\n} from \"@turf/helpers\";\n\n/**\n * Returns a random position within a {@link BBox|bounding box}.\n *\n * @function\n * @param {BBox} [bbox=[-180, -90, 180, 90]] a bounding box inside of which positions are placed.\n * @returns {Position} Position [longitude, latitude]\n * @throws {Error} if bbox is invalid\n * @example\n * var position = turf.randomPosition([-180, -90, 180, 90])\n * // => position\n */\nfunction randomPosition(bbox?: BBox | { bbox: BBox }): Position {\n  checkBBox(bbox);\n  return randomPositionUnchecked(bbox);\n}\n\n// does not check bbox for validity, that is handled by the exported functions\nfunction randomPositionUnchecked(bbox?: BBox | { bbox: BBox }): Position {\n  if (Array.isArray(bbox)) {\n    return coordInBBox(bbox);\n  }\n  if (bbox && bbox.bbox) {\n    return coordInBBox(bbox.bbox);\n  }\n  return [lon(), lat()];\n}\n\nfunction checkBBox(bbox?: BBox | { bbox: BBox }) {\n  if (bbox == null) {\n    return;\n  } else if (Array.isArray(bbox)) {\n    validateBBox(bbox);\n  } else if (bbox.bbox != null) {\n    validateBBox(bbox.bbox);\n  }\n}\n\n/**\n * Returns a random {@link point}.\n *\n * @function\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {BBox} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @returns {FeatureCollection<Point>} GeoJSON FeatureCollection of points\n * @throws {Error} if bbox is invalid\n * @example\n * var points = turf.randomPoint(25, {bbox: [-180, -90, 180, 90]})\n * // => points\n */\nfunction randomPoint(\n  count?: number,\n  options: {\n    bbox?: BBox;\n  } = {}\n): FeatureCollection<Point, any> {\n  checkBBox(options.bbox);\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    features.push(point(randomPositionUnchecked(options.bbox)));\n  }\n  return featureCollection(features);\n}\n\n/**\n * Returns a random {@link polygon}.\n *\n * @function\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {BBox} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_radial_length=10] is the maximum number of decimal degrees latitude or longitude that a\n * vertex can reach out of the center of the Polygon.\n * @returns {FeatureCollection<Polygon>} GeoJSON FeatureCollection of polygons\n * @throws {Error} if bbox is invalid\n * @example\n * var polygons = turf.randomPolygon(25, {bbox: [-180, -90, 180, 90]})\n * // => polygons\n */\nfunction randomPolygon(\n  count?: number,\n  options: {\n    bbox?: BBox;\n    num_vertices?: number;\n    max_radial_length?: number;\n  } = {}\n): FeatureCollection<Polygon, any> {\n  checkBBox(options.bbox);\n\n  // Default param\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n  if (options.bbox === undefined || options.bbox === null) {\n    options.bbox = [-180, -90, 180, 90];\n  }\n  if (!isNumber(options.num_vertices) || options.num_vertices === undefined) {\n    options.num_vertices = 10;\n  }\n  if (\n    !isNumber(options.max_radial_length) ||\n    options.max_radial_length === undefined\n  ) {\n    options.max_radial_length = 10;\n  }\n\n  const bboxWidth = Math.abs(options.bbox[0] - options.bbox[2]);\n  const bboxHeight = Math.abs(options.bbox[1] - options.bbox[3]);\n\n  const maxRadius = Math.min(bboxWidth / 2, bboxHeight / 2);\n\n  if (options.max_radial_length > maxRadius) {\n    throw new Error(\"max_radial_length is greater than the radius of the bbox\");\n  }\n\n  // Create a padded bbox to avoid the polygons to be too close to the border\n  const paddedBbox = [\n    options.bbox[0] + options.max_radial_length,\n    options.bbox[1] + options.max_radial_length,\n    options.bbox[2] - options.max_radial_length,\n    options.bbox[3] - options.max_radial_length,\n  ] as BBox;\n\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    let vertices: number[][] = [];\n    const circleOffsets = [...Array(options.num_vertices + 1)].map(Math.random);\n\n    // Sum Offsets\n    circleOffsets.forEach((cur, index, arr) => {\n      arr[index] = index > 0 ? cur + arr[index - 1] : cur;\n    });\n\n    // scaleOffsets\n    circleOffsets.forEach((cur) => {\n      cur = (cur * 2 * Math.PI) / circleOffsets[circleOffsets.length - 1];\n      const radialScaler = Math.random();\n      vertices.push([\n        radialScaler * (options.max_radial_length || 10) * Math.sin(cur),\n        radialScaler * (options.max_radial_length || 10) * Math.cos(cur),\n      ]);\n    });\n    vertices[vertices.length - 1] = vertices[0]; // close the ring\n\n    // center the polygon around something\n    vertices = vertices\n      .reverse() // Make counter-clockwise to adhere to right hand rule.\n      .map(vertexToCoordinate(randomPositionUnchecked(paddedBbox)));\n    features.push(polygon([vertices]));\n  }\n  return featureCollection(features);\n}\n\n/**\n * Returns a random {@link LineString}.\n *\n * @function\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {BBox} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_length=0.0001] is the maximum number of decimal degrees that a\n * vertex can be from its predecessor\n * @param {number} [options.max_rotation=Math.PI / 8] is the maximum number of radians that a\n * line segment can turn from the previous segment.\n * @returns {FeatureCollection<LineString>} GeoJSON FeatureCollection of linestrings\n * @throws {Error} if bbox is invalid\n * @example\n * var lineStrings = turf.randomLineString(25, {bbox: [-180, -90, 180, 90]})\n * // => lineStrings\n */\nfunction randomLineString(\n  count?: number,\n  options: {\n    bbox?: BBox;\n    num_vertices?: number;\n    max_length?: number;\n    max_rotation?: number;\n  } = {}\n): FeatureCollection<LineString, any> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const bbox = options.bbox;\n  checkBBox(bbox);\n  let num_vertices = options.num_vertices;\n  let max_length = options.max_length;\n  let max_rotation = options.max_rotation;\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n\n  // Default parameters\n  if (\n    !isNumber(num_vertices) ||\n    num_vertices === undefined ||\n    num_vertices < 2\n  ) {\n    num_vertices = 10;\n  }\n  if (!isNumber(max_length) || max_length === undefined) {\n    max_length = 0.0001;\n  }\n  if (!isNumber(max_rotation) || max_rotation === undefined) {\n    max_rotation = Math.PI / 8;\n  }\n\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    const startingPoint = randomPositionUnchecked(bbox);\n    const vertices = [startingPoint];\n    for (let j = 0; j < num_vertices - 1; j++) {\n      const priorAngle =\n        j === 0\n          ? Math.random() * 2 * Math.PI\n          : Math.tan(\n              (vertices[j][1] - vertices[j - 1][1]) /\n                (vertices[j][0] - vertices[j - 1][0])\n            );\n      const angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;\n      const distance = Math.random() * max_length;\n      vertices.push([\n        vertices[j][0] + distance * Math.cos(angle),\n        vertices[j][1] + distance * Math.sin(angle),\n      ]);\n    }\n    features.push(lineString(vertices));\n  }\n\n  return featureCollection(features);\n}\n\nfunction vertexToCoordinate(hub: number[]) {\n  return (cur: number[]) => {\n    return [cur[0] + hub[0], cur[1] + hub[1]];\n  };\n}\n\nfunction rnd() {\n  return Math.random() - 0.5;\n}\nfunction lon() {\n  return rnd() * 360;\n}\nfunction lat() {\n  return rnd() * 180;\n}\n\nfunction coordInBBox(bbox: BBox) {\n  return [\n    Math.random() * (bbox[2] - bbox[0]) + bbox[0],\n    Math.random() * (bbox[3] - bbox[1]) + bbox[1],\n  ];\n}\n\nexport { randomPosition, randomPoint, randomPolygon, randomLineString };\n"],"mappings":"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","names":[]}