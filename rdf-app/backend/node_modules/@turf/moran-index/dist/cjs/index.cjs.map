{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-moran-index/dist/cjs/index.cjs","../../index.ts"],"names":["moranIndex"],"mappings":"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","file":"/home/runner/work/turf/turf/packages/turf-moran-index/dist/cjs/index.cjs","sourcesContent":[null,"import { FeatureCollection } from \"geojson\";\nimport { distanceWeight as spatialWeight } from \"@turf/distance-weight\";\nimport { featureEach } from \"@turf/meta\";\n\n/**\n * @typedef {object} MoranIndex\n * @property {number} moranIndex the moran's Index of the observed feature set\n * @property {number} expectedMoranIndex the moran's Index of the random distribution\n * @property {number} stdNorm the standard devitaion of the random distribution\n * @property {number} zNorm the z-score of the observe samples with regard to the random distribution\n */\ntype MoranIndex = {\n  moranIndex: number;\n  expectedMoranIndex: number;\n  stdNorm: number;\n  zNorm: number;\n};\n\n/**\n * Moran's I measures patterns of attribute values associated with features.\n * The method reveal whether similar values tend to occur near each other,\n * or whether high or low values are interspersed.\n *\n * Moran's I > 0 means a clusterd pattern.\n * Moran's I < 0 means a dispersed pattern.\n * Moran's I = 0 means a random pattern.\n *\n * In order to test the significance of the result. The z score is calculated.\n * A positive enough z-score (ex. >1.96) indicates clustering,\n * while a negative enough z-score (ex. <-1.96) indicates a dispersed pattern.\n *\n * the z-score can be calculated based on a normal or random assumption.\n *\n * **Bibliography***\n *\n * 1. [Moran's I](https://en.wikipedia.org/wiki/Moran%27s_I)\n *\n * 2. [pysal](http://pysal.readthedocs.io/en/latest/index.html)\n *\n * 3. Andy Mitchell, The ESRI Guide to GIS Analysis Volume 2: Spatial Measurements & Statistics.\n *\n * @function\n * @param {FeatureCollection<any>} fc\n * @param {Object} options\n * @param {string} options.inputField the property name, must contain numeric values\n * @param {number} [options.threshold=100000] the distance threshold\n * @param {number} [options.p=2] the Minkowski p-norm distance parameter\n * @param {boolean} [options.binary=false] whether transfrom the distance to binary\n * @param {number} [options.alpha=-1] the distance decay parameter\n * @param {boolean} [options.standardization=true] wheter row standardization the distance\n * @returns {MoranIndex}\n * @example\n *\n * const bbox = [-65, 40, -63, 42];\n * const dataset = turf.randomPoint(100, { bbox: bbox });\n *\n * const result = turf.moranIndex(dataset, {\n *   inputField: 'CRIME',\n * });\n */\n\nfunction moranIndex(\n  fc: FeatureCollection<any>,\n  options: {\n    inputField: string;\n    threshold?: number;\n    p?: number;\n    binary?: boolean;\n    alpha?: number;\n    standardization?: boolean;\n  }\n): MoranIndex {\n  const inputField = options.inputField;\n  const threshold = options.threshold || 100000;\n  const p = options.p || 2;\n  const binary = options.binary ?? false;\n  const alpha = options.alpha || -1;\n  const standardization = options.standardization ?? true;\n\n  const weight = spatialWeight(fc, {\n    alpha,\n    binary,\n    p,\n    standardization,\n    threshold,\n  });\n\n  const y: number[] = [];\n  featureEach(fc, (feature) => {\n    const feaProperties = feature.properties || {};\n    // validate inputField exists\n    y.push(feaProperties[inputField]);\n  });\n\n  const yMean = mean(y);\n  const yVar = variance(y);\n  let weightSum = 0;\n  let s0 = 0;\n  let s1 = 0;\n  let s2 = 0;\n  const n = weight.length;\n  // validate y.length is the same as weight.length\n  for (let i = 0; i < n; i++) {\n    let subS2 = 0;\n    for (let j = 0; j < n; j++) {\n      weightSum += weight[i][j] * (y[i] - yMean) * (y[j] - yMean);\n      s0 += weight[i][j];\n      s1 += Math.pow(weight[i][j] + weight[j][i], 2);\n      subS2 += weight[i][j] + weight[j][i];\n    }\n    s2 += Math.pow(subS2, 2);\n  }\n  s1 = 0.5 * s1;\n\n  const moranIndex = weightSum / s0 / yVar;\n  const expectedMoranIndex = -1 / (n - 1);\n  const vNum = n * n * s1 - n * s2 + 3 * (s0 * s0);\n  const vDen = (n - 1) * (n + 1) * (s0 * s0);\n  const vNorm = vNum / vDen - expectedMoranIndex * expectedMoranIndex;\n  const stdNorm = Math.sqrt(vNorm);\n  const zNorm = (moranIndex - expectedMoranIndex) / stdNorm;\n\n  return {\n    expectedMoranIndex,\n    moranIndex,\n    stdNorm,\n    zNorm,\n  };\n}\n\n/**\n * get mean of a list\n *\n * @private\n * @param {number[]} y\n * @returns {number}\n *\n */\nfunction mean(y: number[]): number {\n  let sum = 0;\n  for (const item of y) {\n    sum += item;\n  }\n  return sum / y.length;\n}\n/**\n * get variance of a list\n *\n * @private\n * @param {number[]} y\n * @returns {number}\n *\n */\nfunction variance(y: number[]): number {\n  const yMean = mean(y);\n  let sum = 0;\n  for (const item of y) {\n    sum += Math.pow(item - yMean, 2);\n  }\n  return sum / y.length;\n}\n\nexport { moranIndex, MoranIndex };\nexport default moranIndex;\n"]}