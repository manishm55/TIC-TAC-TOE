{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-polygon-tangents/dist/cjs/index.cjs","../../index.ts"],"names":[],"mappings":"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","file":"/home/runner/work/turf/turf/packages/turf-polygon-tangents/dist/cjs/index.cjs","sourcesContent":[null,"import type {\n  Feature,\n  FeatureCollection,\n  Point,\n  Polygon,\n  Position,\n  MultiPolygon,\n} from \"geojson\";\nimport type { Coord } from \"@turf/helpers\";\nimport { getCoords, getType } from \"@turf/invariant\";\nimport { point, featureCollection } from \"@turf/helpers\";\nimport { bbox as calcBbox } from \"@turf/bbox\";\nimport { explode } from \"@turf/explode\";\nimport { nearestPoint } from \"@turf/nearest-point\";\n\n/**\n * Finds the tangents of a {@link Polygon|(Multi)Polygon} from a {@link Point}.\n *\n * @function\n * @param {Coord} pt to calculate the tangent points from\n * @param {Feature<Polygon|MultiPolygon>} polygon to get tangents from\n * @returns {FeatureCollection<Point>} Feature Collection containing the two tangent points\n * @example\n * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\n * var point = turf.point([61, 5]);\n *\n * var tangents = turf.polygonTangents(point, polygon)\n *\n * //addToMap\n * var addToMap = [tangents, point, polygon];\n */\nfunction polygonTangents<T extends Polygon | MultiPolygon>(\n  pt: Coord,\n  polygon: Feature<T> | T\n): FeatureCollection<Point> {\n  const pointCoords = getCoords(pt);\n  const polyCoords = getCoords(polygon);\n\n  let rtan: Position = [];\n  let ltan: Position = [];\n  let eprev: number;\n  const bbox = calcBbox(polygon);\n  let nearestPtIndex = 0;\n  let nearest = null;\n\n  // If the point lies inside the polygon bbox then we need to be a bit trickier\n  // otherwise points lying inside reflex angles on concave polys can have issues\n  if (\n    pointCoords[0] > bbox[0] &&\n    pointCoords[0] < bbox[2] &&\n    pointCoords[1] > bbox[1] &&\n    pointCoords[1] < bbox[3]\n  ) {\n    nearest = nearestPoint(pt, explode(polygon));\n    nearestPtIndex = nearest.properties.featureIndex;\n  }\n  const type = getType(polygon);\n  switch (type) {\n    case \"Polygon\":\n      rtan = polyCoords[0][nearestPtIndex];\n      ltan = polyCoords[0][0];\n      if (nearest !== null) {\n        if (nearest.geometry.coordinates[1] < pointCoords[1])\n          ltan = polyCoords[0][nearestPtIndex];\n      }\n      eprev = isLeft(\n        polyCoords[0][0],\n        polyCoords[0][polyCoords[0].length - 1],\n        pointCoords\n      );\n      [rtan, ltan] = processPolygon(\n        polyCoords[0],\n        pointCoords,\n        eprev,\n        rtan,\n        ltan\n      );\n      break;\n    case \"MultiPolygon\":\n      var closestFeature = 0;\n      var closestVertex = 0;\n      var verticesCounted = 0;\n      for (var i = 0; i < polyCoords[0].length; i++) {\n        closestFeature = i;\n        var verticeFound = false;\n        for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {\n          closestVertex = i2;\n          if (verticesCounted === nearestPtIndex) {\n            verticeFound = true;\n            break;\n          }\n          verticesCounted++;\n        }\n        if (verticeFound) break;\n      }\n      rtan = polyCoords[0][closestFeature][closestVertex];\n      ltan = polyCoords[0][closestFeature][closestVertex];\n      eprev = isLeft(\n        polyCoords[0][0][0],\n        polyCoords[0][0][polyCoords[0][0].length - 1],\n        pointCoords\n      );\n      polyCoords.forEach(function (ring) {\n        [rtan, ltan] = processPolygon(ring[0], pointCoords, eprev, rtan, ltan);\n      });\n      break;\n  }\n  return featureCollection([point(rtan), point(ltan)]);\n}\n\nfunction processPolygon(\n  polygonCoords: Position[],\n  ptCoords: Position,\n  eprev: number,\n  rtan: Position,\n  ltan: Position\n) {\n  for (let i = 0; i < polygonCoords.length; i++) {\n    const currentCoords = polygonCoords[i];\n    let nextCoordPair = polygonCoords[i + 1];\n    if (i === polygonCoords.length - 1) {\n      nextCoordPair = polygonCoords[0];\n    }\n    const enext = isLeft(currentCoords, nextCoordPair, ptCoords);\n    if (eprev <= 0 && enext > 0) {\n      if (!isBelow(ptCoords, currentCoords, rtan)) {\n        rtan = currentCoords;\n      }\n    } else if (eprev > 0 && enext <= 0) {\n      if (!isAbove(ptCoords, currentCoords, ltan)) {\n        ltan = currentCoords;\n      }\n    }\n    eprev = enext;\n  }\n  return [rtan, ltan];\n}\n\nfunction isAbove(point1: Position, point2: Position, point3: Position) {\n  return isLeft(point1, point2, point3) > 0;\n}\n\nfunction isBelow(point1: Position, point2: Position, point3: Position) {\n  return isLeft(point1, point2, point3) < 0;\n}\n\nfunction isLeft(point1: Position, point2: Position, point3: Position) {\n  return (\n    (point2[0] - point1[0]) * (point3[1] - point1[1]) -\n    (point3[0] - point1[0]) * (point2[1] - point1[1])\n  );\n}\n\nexport { polygonTangents };\nexport default polygonTangents;\n"]}