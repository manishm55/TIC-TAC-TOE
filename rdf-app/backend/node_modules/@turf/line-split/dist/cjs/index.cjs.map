{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-line-split/dist/cjs/index.cjs","../../index.js"],"names":["line"],"mappings":"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","file":"/home/runner/work/turf/turf/packages/turf-line-split/dist/cjs/index.cjs","sourcesContent":[null,"import { geojsonRbush as rbush } from \"@turf/geojson-rbush\";\nimport { square } from \"@turf/square\";\nimport { bbox } from \"@turf/bbox\";\nimport { truncate } from \"@turf/truncate\";\nimport { lineSegment } from \"@turf/line-segment\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\nimport { getCoords, getCoord, getType } from \"@turf/invariant\";\nimport { featureEach, featureReduce, flattenEach } from \"@turf/meta\";\nimport { lineString, featureCollection } from \"@turf/helpers\";\n\n/**\n * Split a LineString by another GeoJSON Feature.\n *\n * @function\n * @param {Feature<LineString>} line LineString Feature to split\n * @param {Feature<any>} splitter Feature used to split line\n * @returns {FeatureCollection<LineString>} Split LineStrings\n * @example\n * var line = turf.lineString([[120, -25], [145, -25]]);\n * var splitter = turf.lineString([[130, -15], [130, -35]]);\n *\n * var split = turf.lineSplit(line, splitter);\n *\n * //addToMap\n * var addToMap = [line, splitter]\n */\nfunction lineSplit(line, splitter) {\n  if (!line) throw new Error(\"line is required\");\n  if (!splitter) throw new Error(\"splitter is required\");\n\n  var lineType = getType(line);\n  var splitterType = getType(splitter);\n\n  if (lineType !== \"LineString\") throw new Error(\"line must be LineString\");\n  if (splitterType === \"FeatureCollection\")\n    throw new Error(\"splitter cannot be a FeatureCollection\");\n  if (splitterType === \"GeometryCollection\")\n    throw new Error(\"splitter cannot be a GeometryCollection\");\n\n  // remove excessive decimals from splitter\n  // to avoid possible approximation issues in rbush\n  var truncatedSplitter = truncate(splitter, { precision: 7 });\n\n  switch (splitterType) {\n    case \"Point\":\n      return splitLineWithPoint(line, truncatedSplitter);\n    case \"MultiPoint\":\n      return splitLineWithPoints(line, truncatedSplitter);\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"Polygon\":\n    case \"MultiPolygon\":\n      return splitLineWithPoints(\n        line,\n        lineIntersect(line, truncatedSplitter, {\n          ignoreSelfIntersections: true,\n        })\n      );\n  }\n}\n\n/**\n * Split LineString with MultiPoint\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {FeatureCollection<Point>} splitter Point\n * @returns {FeatureCollection<LineString>} split LineStrings\n */\nfunction splitLineWithPoints(line, splitter) {\n  var results = [];\n  var tree = rbush();\n\n  flattenEach(splitter, function (point) {\n    // Add index/id to features (needed for filter)\n    results.forEach(function (feature, index) {\n      feature.id = index;\n    });\n    // First Point - doesn't need to handle any previous line results\n    if (!results.length) {\n      results = splitLineWithPoint(line, point).features;\n\n      // Add Square BBox to each feature for GeoJSON-RBush\n      results.forEach(function (feature) {\n        if (!feature.bbox) feature.bbox = square(bbox(feature));\n      });\n      tree.load(featureCollection(results));\n      // Split with remaining points - lines might needed to be split multiple times\n    } else {\n      // Find all lines that are within the splitter's bbox\n      var search = tree.search(point);\n\n      if (search.features.length) {\n        // RBush might return multiple lines - only process the closest line to splitter\n        var closestLine = findClosestFeature(point, search);\n\n        // Remove closest line from results since this will be split into two lines\n        // This removes any duplicates inside the results & index\n        results = results.filter(function (feature) {\n          return feature.id !== closestLine.id;\n        });\n        tree.remove(closestLine);\n\n        // Append the two newly split lines into the results\n        featureEach(splitLineWithPoint(closestLine, point), function (line) {\n          results.push(line);\n          tree.insert(line);\n        });\n      }\n    }\n  });\n  return featureCollection(results);\n}\n\n/**\n * Split LineString with Point\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<Point>} splitter Point\n * @returns {FeatureCollection<LineString>} split LineStrings\n */\nfunction splitLineWithPoint(line, splitter) {\n  var results = [];\n\n  // handle endpoints\n  var startPoint = getCoords(line)[0];\n  var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];\n  if (\n    pointsEquals(startPoint, getCoord(splitter)) ||\n    pointsEquals(endPoint, getCoord(splitter))\n  )\n    return featureCollection([line]);\n\n  // Create spatial index\n  var tree = rbush();\n  var segments = lineSegment(line);\n  tree.load(segments);\n\n  // Find all segments that are within bbox of splitter\n  var search = tree.search(splitter);\n\n  // Return itself if point is not within spatial index\n  if (!search.features.length) return featureCollection([line]);\n\n  // RBush might return multiple lines - only process the closest line to splitter\n  var closestSegment = findClosestFeature(splitter, search);\n\n  // Initial value is the first point of the first segments (beginning of line)\n  var initialValue = [startPoint];\n  var lastCoords = featureReduce(\n    segments,\n    function (previous, current, index) {\n      var currentCoords = getCoords(current)[1];\n      var splitterCoords = getCoord(splitter);\n\n      // Location where segment intersects with line\n      if (index === closestSegment.id) {\n        previous.push(splitterCoords);\n        results.push(lineString(previous));\n        // Don't duplicate splitter coordinate (Issue #688)\n        if (pointsEquals(splitterCoords, currentCoords))\n          return [splitterCoords];\n        return [splitterCoords, currentCoords];\n\n        // Keep iterating over coords until finished or intersection is found\n      } else {\n        previous.push(currentCoords);\n        return previous;\n      }\n    },\n    initialValue\n  );\n  // Append last line to final split results\n  if (lastCoords.length > 1) {\n    results.push(lineString(lastCoords));\n  }\n  return featureCollection(results);\n}\n\n/**\n * Find Closest Feature\n *\n * @private\n * @param {Feature<Point>} point Feature must be closest to this point\n * @param {FeatureCollection<LineString>} lines Collection of Features\n * @returns {Feature<LineString>} closest LineString\n */\nfunction findClosestFeature(point, lines) {\n  if (!lines.features.length) throw new Error(\"lines must contain features\");\n  // Filter to one segment that is the closest to the line\n  if (lines.features.length === 1) return lines.features[0];\n\n  var closestFeature;\n  var closestDistance = Infinity;\n  featureEach(lines, function (segment) {\n    var pt = nearestPointOnLine(segment, point);\n    var dist = pt.properties.dist;\n    if (dist < closestDistance) {\n      closestFeature = segment;\n      closestDistance = dist;\n    }\n  });\n  return closestFeature;\n}\n\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Array<number>} pt1 point\n * @param {Array<number>} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction pointsEquals(pt1, pt2) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n\nexport { lineSplit };\nexport default lineSplit;\n"]}