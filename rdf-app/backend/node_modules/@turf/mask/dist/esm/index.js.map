{"version":3,"sources":["../../index.ts"],"sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  Polygon,\n  Position,\n  MultiPolygon,\n} from \"geojson\";\nimport { polygon as createPolygon, multiPolygon } from \"@turf/helpers\";\nimport * as polyclip from \"polyclip-ts\";\nimport { clone } from \"@turf/clone\";\n\n/**\n * Takes polygons or multipolygons and an optional mask, and returns an exterior\n * ring polygon with holes.\n *\n * @function\n * @param {Polygon|MultiPolygon|Feature<Polygon|MultiPolygon>|FeatureCollection<Polygon|MultiPolygon>} polygon GeoJSON polygon used as interior rings or holes\n * @param {Polygon|Feature<Polygon>} [mask] GeoJSON polygon used as the exterior ring (if undefined, the world extent is used)\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] allows the `mask` GeoJSON input to be mutated (performance improvement if true)\n * @returns {Feature<Polygon>} Masked Polygon (exterior ring with holes)\n * @example\n * const polygon = turf.polygon([[[112, -21], [116, -36], [146, -39], [153, -24], [133, -10], [112, -21]]]);\n * const mask = turf.polygon([[[90, -55], [170, -55], [170, 10], [90, 10], [90, -55]]]);\n *\n * const masked = turf.mask(polygon, mask);\n *\n * //addToMap\n * const addToMap = [masked]\n */\nfunction mask<T extends Polygon | MultiPolygon>(\n  polygon: T | Feature<T> | FeatureCollection<T>,\n  mask?: Polygon | Feature<Polygon>,\n  options?: { mutate?: boolean }\n): Feature<Polygon> {\n  const mutate = options?.mutate ?? false; // by default, do not mutate\n\n  let maskTemplate = mask;\n  if (mask && mutate === false) {\n    // Clone mask if requested to avoid side effects\n    maskTemplate = clone(mask);\n  }\n\n  // Define initial mask\n  const maskPolygon = createMask(maskTemplate);\n\n  let polygonOuters = null;\n  if (polygon.type === \"FeatureCollection\") {\n    polygonOuters = unionFc(polygon);\n  } else if (polygon.type === \"Feature\") {\n    // Need to cast below as Position[][] isn't quite as strict as Geom, even\n    // though they should be equivalent.\n    polygonOuters = createGeomFromPolygonClippingOutput(\n      polyclip.union(polygon.geometry.coordinates as polyclip.Geom)\n    );\n  } else {\n    // Geometry\n    // Need to cast below as Position[][] isn't quite as strict as Geom, even\n    // though they should be equivalent.\n    polygonOuters = createGeomFromPolygonClippingOutput(\n      polyclip.union(polygon.coordinates as polyclip.Geom)\n    );\n  }\n\n  polygonOuters.geometry.coordinates.forEach(function (contour) {\n    maskPolygon.geometry.coordinates.push(contour[0]);\n  });\n\n  return maskPolygon;\n}\n\nfunction unionFc(fc: FeatureCollection<Polygon | MultiPolygon>) {\n  // Need to cast below as Position[][] isn't quite as strict as Geom, even\n  // though they should be equivalent.\n\n  // Stick with apply() below as spread operator degrades performance. Have\n  // to disable prefer-spread lint rule though.\n  /* eslint-disable prefer-spread */\n  const unioned =\n    fc.features.length === 2\n      ? polyclip.union(\n          fc.features[0].geometry.coordinates as polyclip.Geom,\n          fc.features[1].geometry.coordinates as polyclip.Geom\n        )\n      : polyclip.union.apply(\n          polyclip,\n          fc.features.map(function (f) {\n            return f.geometry.coordinates;\n          }) as [polyclip.Geom, ...polyclip.Geom[]]\n        );\n  /* eslint-enable */\n  return createGeomFromPolygonClippingOutput(unioned);\n}\n\nfunction createGeomFromPolygonClippingOutput(unioned: Position[][][]) {\n  return multiPolygon(unioned);\n}\n\n/**\n * Create Mask Coordinates\n *\n * @private\n * @param {Feature<Polygon>} [mask] default to world if undefined\n * @returns {Feature<Polygon>} mask as a polygon\n */\nfunction createMask(mask: Feature<Polygon> | Polygon | undefined) {\n  const world = [\n    [\n      [180, 90],\n      [-180, 90],\n      [-180, -90],\n      [180, -90],\n      [180, 90],\n    ],\n  ];\n  let coordinates = world;\n  if (mask) {\n    if (mask.type === \"Feature\") {\n      // polygon feature\n      coordinates = mask.geometry.coordinates;\n    } else {\n      // polygon geometry\n      coordinates = mask.coordinates;\n    }\n  }\n  return createPolygon(coordinates);\n}\n\nexport { mask };\nexport default mask;\n"],"mappings":";AAOA,SAAS,WAAW,eAAe,oBAAoB;AACvD,YAAY,cAAc;AAC1B,SAAS,aAAa;AAqBtB,SAAS,KACP,SACAA,OACA,SACkB;AAlCpB;AAmCE,QAAM,UAAS,wCAAS,WAAT,YAAmB;AAElC,MAAI,eAAeA;AACnB,MAAIA,SAAQ,WAAW,OAAO;AAE5B,mBAAe,MAAMA,KAAI;AAAA,EAC3B;AAGA,QAAM,cAAc,WAAW,YAAY;AAE3C,MAAI,gBAAgB;AACpB,MAAI,QAAQ,SAAS,qBAAqB;AACxC,oBAAgB,QAAQ,OAAO;AAAA,EACjC,WAAW,QAAQ,SAAS,WAAW;AAGrC,oBAAgB;AAAA,MACL,eAAM,QAAQ,SAAS,WAA4B;AAAA,IAC9D;AAAA,EACF,OAAO;AAIL,oBAAgB;AAAA,MACL,eAAM,QAAQ,WAA4B;AAAA,IACrD;AAAA,EACF;AAEA,gBAAc,SAAS,YAAY,QAAQ,SAAU,SAAS;AAC5D,gBAAY,SAAS,YAAY,KAAK,QAAQ,CAAC,CAAC;AAAA,EAClD,CAAC;AAED,SAAO;AACT;AAEA,SAAS,QAAQ,IAA+C;AAO9D,QAAM,UACJ,GAAG,SAAS,WAAW,IACV;AAAA,IACP,GAAG,SAAS,CAAC,EAAE,SAAS;AAAA,IACxB,GAAG,SAAS,CAAC,EAAE,SAAS;AAAA,EAC1B,IACS,eAAM;AAAA,IACb;AAAA,IACA,GAAG,SAAS,IAAI,SAAU,GAAG;AAC3B,aAAO,EAAE,SAAS;AAAA,IACpB,CAAC;AAAA,EACH;AAEN,SAAO,oCAAoC,OAAO;AACpD;AAEA,SAAS,oCAAoC,SAAyB;AACpE,SAAO,aAAa,OAAO;AAC7B;AASA,SAAS,WAAWA,OAA8C;AAChE,QAAM,QAAQ;AAAA,IACZ;AAAA,MACE,CAAC,KAAK,EAAE;AAAA,MACR,CAAC,MAAM,EAAE;AAAA,MACT,CAAC,MAAM,GAAG;AAAA,MACV,CAAC,KAAK,GAAG;AAAA,MACT,CAAC,KAAK,EAAE;AAAA,IACV;AAAA,EACF;AACA,MAAI,cAAc;AAClB,MAAIA,OAAM;AACR,QAAIA,MAAK,SAAS,WAAW;AAE3B,oBAAcA,MAAK,SAAS;AAAA,IAC9B,OAAO;AAEL,oBAAcA,MAAK;AAAA,IACrB;AAAA,EACF;AACA,SAAO,cAAc,WAAW;AAClC;AAGA,IAAO,oBAAQ;","names":["mask"]}