{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-point-to-line-distance/dist/cjs/index.cjs","../../index.ts"],"names":[],"mappings":"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","file":"/home/runner/work/turf/turf/packages/turf-point-to-line-distance/dist/cjs/index.cjs","sourcesContent":[null,"// Taken from http://geomalgorithms.com/a02-_lines.html\nimport { Feature, LineString } from \"geojson\";\nimport {\n  convertLength,\n  Coord,\n  feature,\n  lineString,\n  point,\n  Units,\n} from \"@turf/helpers\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\nimport { featureOf } from \"@turf/invariant\";\nimport { segmentEach } from \"@turf/meta\";\nimport { rhumbDistance } from \"@turf/rhumb-distance\";\n\n/**\n * Calculates the distance between a given point and the nearest point on a\n * line. Sometimes referred to as the cross track distance.\n *\n * @function\n * @param {Feature<Point>|Array<number>} pt Feature or Geometry\n * @param {Feature<LineString>} line GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be anything supported by turf/convertLength\n * (ex: degrees, radians, miles, or kilometers)\n * @param {string} [options.method=\"geodesic\"] whether to calculate the distance based on geodesic (spheroid) or\n * planar (flat) method. Valid options are 'geodesic' or 'planar'.\n * @returns {number} distance between point and line\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[1, 1],[-1, 1]]);\n *\n * var distance = turf.pointToLineDistance(pt, line, {units: 'miles'});\n * //=69.11854715938406\n */\nfunction pointToLineDistance(\n  pt: Coord,\n  line: Feature<LineString> | LineString,\n  options: {\n    units?: Units;\n    method?: \"geodesic\" | \"planar\";\n  } = {}\n): number {\n  // Optional parameters\n  const method = options.method ?? \"geodesic\";\n  const units = options.units ?? \"kilometers\";\n\n  // validation\n  if (!pt) {\n    throw new Error(\"pt is required\");\n  }\n  if (Array.isArray(pt)) {\n    pt = point(pt);\n  } else if (pt.type === \"Point\") {\n    pt = feature(pt);\n  } else {\n    featureOf(pt, \"Point\", \"point\");\n  }\n\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n  if (Array.isArray(line)) {\n    line = lineString(line);\n  } else if (line.type === \"LineString\") {\n    line = feature(line);\n  } else {\n    featureOf(line, \"LineString\", \"line\");\n  }\n\n  let distance = Infinity;\n  const p = pt.geometry.coordinates;\n  segmentEach(line, (segment) => {\n    if (segment) {\n      const a = segment.geometry.coordinates[0];\n      const b = segment.geometry.coordinates[1];\n      const d = distanceToSegment(p, a, b, { method });\n      if (d < distance) {\n        distance = d;\n      }\n    }\n  });\n  return convertLength(distance, \"degrees\", units);\n}\n\n/**\n * Returns the distance between a point P on a segment AB.\n *\n * @private\n * @param {Array<number>} p external point\n * @param {Array<number>} a first segment point\n * @param {Array<number>} b second segment point\n * @param {Object} [options={}] Optional parameters\n * @returns {number} distance\n */\nfunction distanceToSegment(\n  p: number[], // point to measure from\n  a: number[], // start point of the segment to measure to\n  b: number[], // end point of the segment to measure to\n  options: {\n    method: \"geodesic\" | \"planar\";\n  }\n) {\n  // Internally just use degrees, and then convert to the user's requested units\n  // in the calling function.\n  if (options.method === \"geodesic\") {\n    // Use nearestPointOnLine to properly calculate distances on a spherical\n    // Earth.\n    const nearest = nearestPointOnLine(lineString([a, b]).geometry, p, {\n      units: \"degrees\",\n    });\n    return nearest.properties.dist;\n  }\n\n  // Perform scalar calculations instead using rhumb lines.\n  const v = [b[0] - a[0], b[1] - a[1]];\n  const w = [p[0] - a[0], p[1] - a[1]];\n\n  const c1 = dot(w, v);\n  if (c1 <= 0) {\n    return rhumbDistance(p, a, { units: \"degrees\" });\n  }\n  const c2 = dot(v, v);\n  if (c2 <= c1) {\n    return rhumbDistance(p, b, { units: \"degrees\" });\n  }\n  const b2 = c1 / c2;\n  const Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];\n\n  return rhumbDistance(p, Pb, { units: \"degrees\" });\n}\n\nfunction dot(u: number[], v: number[]) {\n  return u[0] * v[0] + u[1] * v[1];\n}\n\nexport { pointToLineDistance };\nexport default pointToLineDistance;\n"]}