{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-nearest-point-on-line/dist/cjs/index.cjs","../../index.ts"],"names":[],"mappings":"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","file":"/home/runner/work/turf/turf/packages/turf-nearest-point-on-line/dist/cjs/index.cjs","sourcesContent":[null,"import { Feature, Point, Position, LineString, MultiLineString } from \"geojson\";\nimport { distance } from \"@turf/distance\";\nimport { flattenEach } from \"@turf/meta\";\nimport {\n  point,\n  degreesToRadians,\n  radiansToDegrees,\n  Coord,\n  Units,\n} from \"@turf/helpers\";\nimport { getCoord, getCoords } from \"@turf/invariant\";\n\n/**\n * Returns the nearest point on a line to a given point.\n *\n * @function\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain four values: `index`: closest point was found on nth line part, `multiFeatureIndex`: closest point was found on the nth line of the `MultiLineString`, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine<G extends LineString | MultiLineString>(\n  lines: Feature<G> | G,\n  pt: Coord,\n  options: { units?: Units } = {}\n): Feature<\n  Point,\n  {\n    dist: number;\n    index: number;\n    multiFeatureIndex: number;\n    location: number;\n    [key: string]: any;\n  }\n> {\n  if (!lines || !pt) {\n    throw new Error(\"lines and pt are required arguments\");\n  }\n\n  const ptPos = getCoord(pt);\n\n  let closestPt: Feature<\n    Point,\n    { dist: number; index: number; multiFeatureIndex: number; location: number }\n  > = point([Infinity, Infinity], {\n    dist: Infinity,\n    index: -1,\n    multiFeatureIndex: -1,\n    location: -1,\n  });\n\n  let length = 0.0;\n  flattenEach(\n    lines,\n    function (line: any, _featureIndex: number, multiFeatureIndex: number) {\n      const coords: any = getCoords(line);\n\n      for (let i = 0; i < coords.length - 1; i++) {\n        //start - start of current line section\n        const start: Feature<Point, { dist: number }> = point(coords[i]);\n        start.properties.dist = distance(pt, start, options);\n        const startPos = getCoord(start);\n\n        //stop - end of current line section\n        const stop: Feature<Point, { dist: number }> = point(coords[i + 1]);\n        stop.properties.dist = distance(pt, stop, options);\n        const stopPos = getCoord(stop);\n\n        // sectionLength\n        const sectionLength = distance(start, stop, options);\n        let intersectPos: Position;\n        let wasEnd: boolean;\n\n        // Short circuit if snap point is start or end position of the line\n        // segment.\n        if (startPos[0] === ptPos[0] && startPos[1] === ptPos[1]) {\n          [intersectPos, , wasEnd] = [startPos, undefined, false];\n        } else if (stopPos[0] === ptPos[0] && stopPos[1] === ptPos[1]) {\n          [intersectPos, , wasEnd] = [stopPos, undefined, true];\n        } else {\n          // Otherwise, find the nearest point the hard way.\n          [intersectPos, , wasEnd] = nearestPointOnSegment(\n            start.geometry.coordinates,\n            stop.geometry.coordinates,\n            getCoord(pt)\n          );\n        }\n        let intersectPt:\n          | Feature<\n              Point,\n              { dist: number; multiFeatureIndex: number; location: number }\n            >\n          | undefined;\n\n        if (intersectPos) {\n          intersectPt = point(intersectPos, {\n            dist: distance(pt, intersectPos, options),\n            multiFeatureIndex: multiFeatureIndex,\n            location: length + distance(start, intersectPos, options),\n          });\n        }\n\n        if (\n          intersectPt &&\n          intersectPt.properties.dist < closestPt.properties.dist\n        ) {\n          closestPt = {\n            ...intersectPt,\n            properties: {\n              ...intersectPt.properties,\n              // Legacy behaviour where index progresses to next segment # if we\n              // went with the end point this iteration.\n              index: wasEnd ? i + 1 : i,\n            },\n          };\n        }\n\n        // update length\n        length += sectionLength;\n      }\n    }\n  );\n\n  return closestPt;\n}\n\n/*\n * Plan is to externalise these vector functions to a simple third party\n * library.\n * Possible candidate is @amandaghassaei/vector-math though having some import\n * issues.\n */\ntype Vector = [number, number, number];\n\nfunction dot(v1: Vector, v2: Vector): number {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return v1x * v2x + v1y * v2y + v1z * v2z;\n}\n\n// https://en.wikipedia.org/wiki/Cross_product\nfunction cross(v1: Vector, v2: Vector): Vector {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return [v1y * v2z - v1z * v2y, v1z * v2x - v1x * v2z, v1x * v2y - v1y * v2x];\n}\n\nfunction magnitude(v: Vector) {\n  return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2) + Math.pow(v[2], 2));\n}\n\nfunction angle(v1: Vector, v2: Vector): number {\n  const theta = dot(v1, v2) / (magnitude(v1) * magnitude(v2));\n  return Math.acos(Math.min(Math.max(theta, -1), 1));\n}\n\nfunction lngLatToVector(a: Position): Vector {\n  const lat = degreesToRadians(a[1]);\n  const lng = degreesToRadians(a[0]);\n  return [\n    Math.cos(lat) * Math.cos(lng),\n    Math.cos(lat) * Math.sin(lng),\n    Math.sin(lat),\n  ];\n}\n\nfunction vectorToLngLat(v: Vector): Position {\n  const [x, y, z] = v;\n  const lat = radiansToDegrees(Math.asin(z));\n  const lng = radiansToDegrees(Math.atan2(y, x));\n\n  return [lng, lat];\n}\n\nfunction nearestPointOnSegment(\n  posA: Position, // start point of segment to measure to\n  posB: Position, // end point of segment to measure to\n  posC: Position // point to measure from\n): [Position, boolean, boolean] {\n  // Based heavily on this article on finding cross track distance to an arc:\n  // https://gis.stackexchange.com/questions/209540/projecting-cross-track-distance-on-great-circle\n\n  // Convert spherical (lng, lat) to cartesian vector coords (x, y, z)\n  // In the below https://tikz.net/spherical_1/ we convert lng (ðœ™) and lat (ðœƒ)\n  // into vectors with x, y, and z components with a length (r) of 1.\n  const A = lngLatToVector(posA); // the vector from 0,0,0 to posA\n  const B = lngLatToVector(posB); // ... to posB\n  const C = lngLatToVector(posC); // ... to posC\n\n  // Components of target point.\n  const [Cx, Cy, Cz] = C;\n\n  // Calculate coefficients.\n  const [D, E, F] = cross(A, B);\n  const a = E * Cz - F * Cy;\n  const b = F * Cx - D * Cz;\n  const c = D * Cy - E * Cx;\n\n  const f = c * E - b * F;\n  const g = a * F - c * D;\n  const h = b * D - a * E;\n\n  const t = 1 / Math.sqrt(Math.pow(f, 2) + Math.pow(g, 2) + Math.pow(h, 2));\n\n  // Vectors to the two points these great circles intersect.\n  const I1: Vector = [f * t, g * t, h * t];\n  const I2: Vector = [-1 * f * t, -1 * g * t, -1 * h * t];\n\n  // Figure out which is the closest intersection to this segment of the great\n  // circle.\n  const angleAB = angle(A, B);\n  const angleAI1 = angle(A, I1);\n  const angleBI1 = angle(B, I1);\n  const angleAI2 = angle(A, I2);\n  const angleBI2 = angle(B, I2);\n\n  let I: Vector;\n\n  if (\n    (angleAI1 < angleAI2 && angleAI1 < angleBI2) ||\n    (angleBI1 < angleAI2 && angleBI1 < angleBI2)\n  ) {\n    I = I1;\n  } else {\n    I = I2;\n  }\n\n  // I is the closest intersection to the segment, though might not actually be\n  // ON the segment.\n\n  // If angle AI or BI is greater than angleAB, I lies on the circle *beyond* A\n  // and B so use the closest of A or B as the intersection\n  if (angle(A, I) > angleAB || angle(B, I) > angleAB) {\n    if (\n      distance(vectorToLngLat(I), vectorToLngLat(A)) <=\n      distance(vectorToLngLat(I), vectorToLngLat(B))\n    ) {\n      return [vectorToLngLat(A), true, false];\n    } else {\n      return [vectorToLngLat(B), false, true];\n    }\n  }\n\n  // As angleAI nor angleBI don't exceed angleAB, I is on the segment\n  return [vectorToLngLat(I), false, false];\n}\n\nexport { nearestPointOnLine };\nexport default nearestPointOnLine;\n"]}