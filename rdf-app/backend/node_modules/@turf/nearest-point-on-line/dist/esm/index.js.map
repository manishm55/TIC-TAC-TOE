{"version":3,"sources":["../../index.ts"],"sourcesContent":["import { Feature, Point, Position, LineString, MultiLineString } from \"geojson\";\nimport { distance } from \"@turf/distance\";\nimport { flattenEach } from \"@turf/meta\";\nimport {\n  point,\n  degreesToRadians,\n  radiansToDegrees,\n  Coord,\n  Units,\n} from \"@turf/helpers\";\nimport { getCoord, getCoords } from \"@turf/invariant\";\n\n/**\n * Returns the nearest point on a line to a given point.\n *\n * @function\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain four values: `index`: closest point was found on nth line part, `multiFeatureIndex`: closest point was found on the nth line of the `MultiLineString`, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine<G extends LineString | MultiLineString>(\n  lines: Feature<G> | G,\n  pt: Coord,\n  options: { units?: Units } = {}\n): Feature<\n  Point,\n  {\n    dist: number;\n    index: number;\n    multiFeatureIndex: number;\n    location: number;\n    [key: string]: any;\n  }\n> {\n  if (!lines || !pt) {\n    throw new Error(\"lines and pt are required arguments\");\n  }\n\n  const ptPos = getCoord(pt);\n\n  let closestPt: Feature<\n    Point,\n    { dist: number; index: number; multiFeatureIndex: number; location: number }\n  > = point([Infinity, Infinity], {\n    dist: Infinity,\n    index: -1,\n    multiFeatureIndex: -1,\n    location: -1,\n  });\n\n  let length = 0.0;\n  flattenEach(\n    lines,\n    function (line: any, _featureIndex: number, multiFeatureIndex: number) {\n      const coords: any = getCoords(line);\n\n      for (let i = 0; i < coords.length - 1; i++) {\n        //start - start of current line section\n        const start: Feature<Point, { dist: number }> = point(coords[i]);\n        start.properties.dist = distance(pt, start, options);\n        const startPos = getCoord(start);\n\n        //stop - end of current line section\n        const stop: Feature<Point, { dist: number }> = point(coords[i + 1]);\n        stop.properties.dist = distance(pt, stop, options);\n        const stopPos = getCoord(stop);\n\n        // sectionLength\n        const sectionLength = distance(start, stop, options);\n        let intersectPos: Position;\n        let wasEnd: boolean;\n\n        // Short circuit if snap point is start or end position of the line\n        // segment.\n        if (startPos[0] === ptPos[0] && startPos[1] === ptPos[1]) {\n          [intersectPos, , wasEnd] = [startPos, undefined, false];\n        } else if (stopPos[0] === ptPos[0] && stopPos[1] === ptPos[1]) {\n          [intersectPos, , wasEnd] = [stopPos, undefined, true];\n        } else {\n          // Otherwise, find the nearest point the hard way.\n          [intersectPos, , wasEnd] = nearestPointOnSegment(\n            start.geometry.coordinates,\n            stop.geometry.coordinates,\n            getCoord(pt)\n          );\n        }\n        let intersectPt:\n          | Feature<\n              Point,\n              { dist: number; multiFeatureIndex: number; location: number }\n            >\n          | undefined;\n\n        if (intersectPos) {\n          intersectPt = point(intersectPos, {\n            dist: distance(pt, intersectPos, options),\n            multiFeatureIndex: multiFeatureIndex,\n            location: length + distance(start, intersectPos, options),\n          });\n        }\n\n        if (\n          intersectPt &&\n          intersectPt.properties.dist < closestPt.properties.dist\n        ) {\n          closestPt = {\n            ...intersectPt,\n            properties: {\n              ...intersectPt.properties,\n              // Legacy behaviour where index progresses to next segment # if we\n              // went with the end point this iteration.\n              index: wasEnd ? i + 1 : i,\n            },\n          };\n        }\n\n        // update length\n        length += sectionLength;\n      }\n    }\n  );\n\n  return closestPt;\n}\n\n/*\n * Plan is to externalise these vector functions to a simple third party\n * library.\n * Possible candidate is @amandaghassaei/vector-math though having some import\n * issues.\n */\ntype Vector = [number, number, number];\n\nfunction dot(v1: Vector, v2: Vector): number {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return v1x * v2x + v1y * v2y + v1z * v2z;\n}\n\n// https://en.wikipedia.org/wiki/Cross_product\nfunction cross(v1: Vector, v2: Vector): Vector {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return [v1y * v2z - v1z * v2y, v1z * v2x - v1x * v2z, v1x * v2y - v1y * v2x];\n}\n\nfunction magnitude(v: Vector) {\n  return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2) + Math.pow(v[2], 2));\n}\n\nfunction angle(v1: Vector, v2: Vector): number {\n  const theta = dot(v1, v2) / (magnitude(v1) * magnitude(v2));\n  return Math.acos(Math.min(Math.max(theta, -1), 1));\n}\n\nfunction lngLatToVector(a: Position): Vector {\n  const lat = degreesToRadians(a[1]);\n  const lng = degreesToRadians(a[0]);\n  return [\n    Math.cos(lat) * Math.cos(lng),\n    Math.cos(lat) * Math.sin(lng),\n    Math.sin(lat),\n  ];\n}\n\nfunction vectorToLngLat(v: Vector): Position {\n  const [x, y, z] = v;\n  const lat = radiansToDegrees(Math.asin(z));\n  const lng = radiansToDegrees(Math.atan2(y, x));\n\n  return [lng, lat];\n}\n\nfunction nearestPointOnSegment(\n  posA: Position, // start point of segment to measure to\n  posB: Position, // end point of segment to measure to\n  posC: Position // point to measure from\n): [Position, boolean, boolean] {\n  // Based heavily on this article on finding cross track distance to an arc:\n  // https://gis.stackexchange.com/questions/209540/projecting-cross-track-distance-on-great-circle\n\n  // Convert spherical (lng, lat) to cartesian vector coords (x, y, z)\n  // In the below https://tikz.net/spherical_1/ we convert lng (𝜙) and lat (𝜃)\n  // into vectors with x, y, and z components with a length (r) of 1.\n  const A = lngLatToVector(posA); // the vector from 0,0,0 to posA\n  const B = lngLatToVector(posB); // ... to posB\n  const C = lngLatToVector(posC); // ... to posC\n\n  // Components of target point.\n  const [Cx, Cy, Cz] = C;\n\n  // Calculate coefficients.\n  const [D, E, F] = cross(A, B);\n  const a = E * Cz - F * Cy;\n  const b = F * Cx - D * Cz;\n  const c = D * Cy - E * Cx;\n\n  const f = c * E - b * F;\n  const g = a * F - c * D;\n  const h = b * D - a * E;\n\n  const t = 1 / Math.sqrt(Math.pow(f, 2) + Math.pow(g, 2) + Math.pow(h, 2));\n\n  // Vectors to the two points these great circles intersect.\n  const I1: Vector = [f * t, g * t, h * t];\n  const I2: Vector = [-1 * f * t, -1 * g * t, -1 * h * t];\n\n  // Figure out which is the closest intersection to this segment of the great\n  // circle.\n  const angleAB = angle(A, B);\n  const angleAI1 = angle(A, I1);\n  const angleBI1 = angle(B, I1);\n  const angleAI2 = angle(A, I2);\n  const angleBI2 = angle(B, I2);\n\n  let I: Vector;\n\n  if (\n    (angleAI1 < angleAI2 && angleAI1 < angleBI2) ||\n    (angleBI1 < angleAI2 && angleBI1 < angleBI2)\n  ) {\n    I = I1;\n  } else {\n    I = I2;\n  }\n\n  // I is the closest intersection to the segment, though might not actually be\n  // ON the segment.\n\n  // If angle AI or BI is greater than angleAB, I lies on the circle *beyond* A\n  // and B so use the closest of A or B as the intersection\n  if (angle(A, I) > angleAB || angle(B, I) > angleAB) {\n    if (\n      distance(vectorToLngLat(I), vectorToLngLat(A)) <=\n      distance(vectorToLngLat(I), vectorToLngLat(B))\n    ) {\n      return [vectorToLngLat(A), true, false];\n    } else {\n      return [vectorToLngLat(B), false, true];\n    }\n  }\n\n  // As angleAI nor angleBI don't exceed angleAB, I is on the segment\n  return [vectorToLngLat(I), false, false];\n}\n\nexport { nearestPointOnLine };\nexport default nearestPointOnLine;\n"],"mappings":"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","names":[]}