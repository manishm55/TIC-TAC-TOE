{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-square/dist/cjs/index.cjs","../../index.ts"],"names":[],"mappings":"AAAA;ACAA,0CAAyB;AAiBzB,SAAS,MAAA,CAAO,IAAA,EAAkB;AAChC,EAAA,IAAI,KAAA,EAAO,IAAA,CAAK,CAAC,CAAA;AACjB,EAAA,IAAI,MAAA,EAAQ,IAAA,CAAK,CAAC,CAAA;AAClB,EAAA,IAAI,KAAA,EAAO,IAAA,CAAK,CAAC,CAAA;AACjB,EAAA,IAAI,MAAA,EAAQ,IAAA,CAAK,CAAC,CAAA;AAElB,EAAA,IAAI,mBAAA,EAAqB,gCAAA,IAAS,CAAK,KAAA,CAAM,CAAA,EAAG,CAAC,CAAA,EAAG,CAAC,IAAA,EAAM,KAAK,CAAC,CAAA;AACjE,EAAA,IAAI,iBAAA,EAAmB,gCAAA,IAAS,CAAK,KAAA,CAAM,CAAA,EAAG,CAAC,CAAA,EAAG,CAAC,IAAA,EAAM,KAAK,CAAC,CAAA;AAC/D,EAAA,GAAA,CAAI,mBAAA,GAAsB,gBAAA,EAAkB;AAC1C,IAAA,IAAI,iBAAA,EAAA,CAAoB,MAAA,EAAQ,KAAA,EAAA,EAAS,CAAA;AACzC,IAAA,OAAO;AAAA,MACL,IAAA;AAAA,MACA,iBAAA,EAAA,CAAoB,KAAA,EAAO,IAAA,EAAA,EAAQ,CAAA;AAAA,MACnC,IAAA;AAAA,MACA,iBAAA,EAAA,CAAoB,KAAA,EAAO,IAAA,EAAA,EAAQ;AAAA,IACrC,CAAA;AAAA,EACF,EAAA,KAAO;AACL,IAAA,IAAI,mBAAA,EAAA,CAAsB,KAAA,EAAO,IAAA,EAAA,EAAQ,CAAA;AACzC,IAAA,OAAO;AAAA,MACL,mBAAA,EAAA,CAAsB,MAAA,EAAQ,KAAA,EAAA,EAAS,CAAA;AAAA,MACvC,KAAA;AAAA,MACA,mBAAA,EAAA,CAAsB,MAAA,EAAQ,KAAA,EAAA,EAAS,CAAA;AAAA,MACvC;AAAA,IACF,CAAA;AAAA,EACF;AACF;AAGA,IAAO,oBAAA,EAAQ,MAAA;ADjBf;AACE;AACA;AACF,+DAAC","file":"/home/runner/work/turf/turf/packages/turf-square/dist/cjs/index.cjs","sourcesContent":[null,"import { distance } from \"@turf/distance\";\nimport { BBox } from \"geojson\";\n\n/**\n * Takes a bounding box and calculates the minimum square bounding box that\n * would contain the input.\n *\n * @function\n * @param {BBox} bbox extent in [west, south, east, north] order\n * @returns {BBox} a square surrounding `bbox`\n * @example\n * const bbox = [-20, -20, -15, 0];\n * const squared = turf.square(bbox);\n *\n * //addToMap\n * const addToMap = [turf.bboxPolygon(bbox), turf.bboxPolygon(squared)]\n */\nfunction square(bbox: BBox): BBox {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n\n  var horizontalDistance = distance(bbox.slice(0, 2), [east, south]);\n  var verticalDistance = distance(bbox.slice(0, 2), [west, north]);\n  if (horizontalDistance >= verticalDistance) {\n    var verticalMidpoint = (south + north) / 2;\n    return [\n      west,\n      verticalMidpoint - (east - west) / 2,\n      east,\n      verticalMidpoint + (east - west) / 2,\n    ];\n  } else {\n    var horizontalMidpoint = (west + east) / 2;\n    return [\n      horizontalMidpoint - (north - south) / 2,\n      south,\n      horizontalMidpoint + (north - south) / 2,\n      north,\n    ];\n  }\n}\n\nexport { square };\nexport default square;\n"]}