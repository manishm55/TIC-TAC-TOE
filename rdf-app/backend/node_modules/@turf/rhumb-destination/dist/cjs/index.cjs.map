{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-rhumb-destination/dist/cjs/index.cjs","../../index.ts"],"names":[],"mappings":"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","file":"/home/runner/work/turf/turf/packages/turf-rhumb-destination/dist/cjs/index.cjs","sourcesContent":[null,"// https://en.wikipedia.org/wiki/Rhumb_line\nimport { Feature, Point, GeoJsonProperties } from \"geojson\";\nimport {\n  convertLength,\n  Coord,\n  degreesToRadians,\n  earthRadius,\n  point,\n  Units,\n} from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n\n/**\n * Returns the destination {@link Point} having travelled the given distance along a Rhumb line from the\n * origin Point with the (varant) given bearing.\n *\n * @function\n * @param {Coord} origin starting point\n * @param {number} distance distance from the starting point\n * @param {number} bearing varant bearing angle ranging from -180 to 180 degrees from north\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @param {Object} [options.properties={}] translate properties to destination point\n * @returns {Feature<Point>} Destination point.\n * @example\n * var pt = turf.point([-75.343, 39.984], {\"marker-color\": \"F00\"});\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.rhumbDestination(pt, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [pt, destination]\n * destination.properties['marker-color'] = '#00F';\n */\nfunction rhumbDestination<P extends GeoJsonProperties = GeoJsonProperties>(\n  origin: Coord,\n  distance: number,\n  bearing: number,\n  options: {\n    units?: Units;\n    properties?: P;\n  } = {}\n): Feature<Point, P> {\n  const wasNegativeDistance = distance < 0;\n  let distanceInMeters = convertLength(\n    Math.abs(distance),\n    options.units,\n    \"meters\"\n  );\n  if (wasNegativeDistance) distanceInMeters = -Math.abs(distanceInMeters);\n  const coords = getCoord(origin);\n  const destination = calculateRhumbDestination(\n    coords,\n    distanceInMeters,\n    bearing\n  );\n\n  // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)\n  // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678\n  destination[0] +=\n    destination[0] - coords[0] > 180\n      ? -360\n      : coords[0] - destination[0] > 180\n        ? 360\n        : 0;\n  return point(destination, options.properties);\n}\n\n/**\n * Returns the destination point having travelled along a rhumb line from origin point the given\n * distance on the  given bearing.\n * Adapted from Geodesy: http://www.movable-type.co.uk/scripts/latlong.html#rhumblines\n *\n * @private\n * @param   {Array<number>} origin - point\n * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\n * @param   {number} bearing - Bearing in degrees from north.\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n * @returns {Array<number>} Destination point.\n */\nfunction calculateRhumbDestination(\n  origin: number[],\n  distance: number,\n  bearing: number,\n  radius?: number\n) {\n  // Ï† => phi\n  // Î» => lambda\n  // Ïˆ => psi\n  // Î” => Delta\n  // Î´ => delta\n  // Î¸ => theta\n\n  radius = radius === undefined ? earthRadius : Number(radius);\n\n  const delta = distance / radius; // angular distance in radians\n  const lambda1 = (origin[0] * Math.PI) / 180; // to radians, but without normalize to ðœ‹\n  const phi1 = degreesToRadians(origin[1]);\n  const theta = degreesToRadians(bearing);\n\n  const DeltaPhi = delta * Math.cos(theta);\n  let phi2 = phi1 + DeltaPhi;\n\n  // check for some daft bugger going past the pole, normalise latitude if so\n  if (Math.abs(phi2) > Math.PI / 2) {\n    phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;\n  }\n\n  const DeltaPsi = Math.log(\n    Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4)\n  );\n  // E-W course becomes ill-conditioned with 0/0\n  const q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n\n  const DeltaLambda = (delta * Math.sin(theta)) / q;\n  const lambda2 = lambda1 + DeltaLambda;\n\n  return [\n    (((lambda2 * 180) / Math.PI + 540) % 360) - 180,\n    (phi2 * 180) / Math.PI,\n  ]; // normalise to âˆ’180..+180Â°\n}\n\nexport { rhumbDestination };\nexport default rhumbDestination;\n"]}