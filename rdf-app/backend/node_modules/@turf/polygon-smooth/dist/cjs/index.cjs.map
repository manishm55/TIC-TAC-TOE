{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-polygon-smooth/dist/cjs/index.cjs","../../index.ts"],"names":["poly"],"mappings":"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","file":"/home/runner/work/turf/turf/packages/turf-polygon-smooth/dist/cjs/index.cjs","sourcesContent":[null,"import type {\n  Feature,\n  FeatureCollection,\n  Polygon,\n  Position,\n  MultiPolygon,\n} from \"geojson\";\nimport { featureCollection, multiPolygon, polygon } from \"@turf/helpers\";\nimport { coordEach, geomEach } from \"@turf/meta\";\n\n/**\n * Smooths a {@link Polygon} or {@link MultiPolygon}. Based on [Chaikin's algorithm](http://graphics.cs.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html).\n * Warning: may create degenerate polygons.\n *\n * @function\n * @param {FeatureCollection<Polygon|MultiPolygon>|Feature<Polygon|MultiPolygon>|Polygon|MultiPolygon} inputPolys (Multi)Polygon(s) to smooth\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.iterations=1] The number of times to smooth the polygon. A higher value means a smoother polygon.\n * @returns {FeatureCollection<Polygon|MultiPolygon>} FeatureCollection containing the smoothed polygon/multipoylgons\n * @example\n * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\n *\n * var smoothed = turf.polygonSmooth(polygon, {iterations: 3})\n *\n * //addToMap\n * var addToMap = [smoothed, polygon];\n */\nfunction polygonSmooth(\n  inputPolys:\n    | FeatureCollection<Polygon | MultiPolygon>\n    | Feature<Polygon | MultiPolygon>\n    | Polygon\n    | MultiPolygon,\n  options?: {\n    iterations?: number;\n  }\n): FeatureCollection<Polygon | MultiPolygon> {\n  // Optional parameters\n  options = options || {};\n  options.iterations = options.iterations || 1;\n\n  const { iterations } = options;\n\n  const outPolys: Feature<Polygon | MultiPolygon>[] = [];\n  if (!inputPolys) throw new Error(\"inputPolys is required\");\n\n  geomEach(inputPolys, function (geom, geomIndex, properties) {\n    if (geom.type === \"Polygon\") {\n      let outCoords: Position[][] = [[]];\n      for (let i = 0; i < iterations; i++) {\n        let tempOutput: Position[][] = [];\n        let poly = geom;\n        if (i > 0) {\n          poly = polygon(outCoords).geometry;\n        }\n        processPolygon(poly, tempOutput);\n        outCoords = tempOutput.slice(0);\n      }\n      outPolys.push(polygon(outCoords, properties));\n    } else if (geom.type === \"MultiPolygon\") {\n      let outCoords: Position[][][] = [[[]]];\n      for (let y = 0; y < iterations; y++) {\n        let tempOutput: Position[][][] = [];\n        let poly = geom;\n        if (y > 0) {\n          poly = multiPolygon(outCoords).geometry;\n        }\n        processMultiPolygon(poly, tempOutput);\n        outCoords = tempOutput.slice(0);\n      }\n      outPolys.push(multiPolygon(outCoords, properties));\n    } else {\n      throw new Error(\"geometry is invalid, must be Polygon or MultiPolygon\");\n    }\n  });\n\n  return featureCollection(outPolys);\n}\n\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\nfunction processPolygon(poly: Polygon, tempOutput: Position[][]) {\n  var previousCoord: Position;\n  var previousGeometryIndex: number;\n\n  coordEach(\n    poly,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (previousGeometryIndex !== geometryIndex) {\n        tempOutput.push([]);\n      } else {\n        var p0x = previousCoord[0];\n        var p0y = previousCoord[1];\n        var p1x = currentCoord[0];\n        var p1y = currentCoord[1];\n        tempOutput[geometryIndex].push([\n          0.75 * p0x + 0.25 * p1x,\n          0.75 * p0y + 0.25 * p1y,\n        ]);\n        tempOutput[geometryIndex].push([\n          0.25 * p0x + 0.75 * p1x,\n          0.25 * p0y + 0.75 * p1y,\n        ]);\n      }\n      previousCoord = currentCoord;\n      previousGeometryIndex = geometryIndex;\n    },\n    false\n  );\n  tempOutput.forEach(function (ring) {\n    ring.push(ring[0]);\n  });\n}\n\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\nfunction processMultiPolygon(poly: MultiPolygon, tempOutput: Position[][][]) {\n  let previousCoord: Position;\n  let previousMultiFeatureIndex: number;\n  let previousGeometryIndex: number;\n\n  coordEach(\n    poly,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (previousMultiFeatureIndex !== multiFeatureIndex) {\n        tempOutput.push([[]]);\n      } else if (previousGeometryIndex !== geometryIndex) {\n        tempOutput[multiFeatureIndex].push([]);\n      } else {\n        var p0x = previousCoord[0];\n        var p0y = previousCoord[1];\n        var p1x = currentCoord[0];\n        var p1y = currentCoord[1];\n        tempOutput[multiFeatureIndex][geometryIndex].push([\n          0.75 * p0x + 0.25 * p1x,\n          0.75 * p0y + 0.25 * p1y,\n        ]);\n        tempOutput[multiFeatureIndex][geometryIndex].push([\n          0.25 * p0x + 0.75 * p1x,\n          0.25 * p0y + 0.75 * p1y,\n        ]);\n      }\n      previousCoord = currentCoord;\n      previousMultiFeatureIndex = multiFeatureIndex;\n      previousGeometryIndex = geometryIndex;\n    },\n    false\n  );\n  tempOutput.forEach(function (poly) {\n    poly.forEach(function (ring) {\n      ring.push(ring[0]);\n    });\n  });\n}\n\nexport { polygonSmooth };\nexport default polygonSmooth;\n"]}