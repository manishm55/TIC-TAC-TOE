{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-transform-scale/dist/cjs/index.cjs","../../index.ts"],"names":[],"mappings":"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","file":"/home/runner/work/turf/turf/packages/turf-transform-scale/dist/cjs/index.cjs","sourcesContent":[null,"import { Corners, Coord } from \"@turf/helpers\";\nimport { FeatureCollection, GeoJSON, GeometryCollection } from \"geojson\";\nimport { clone } from \"@turf/clone\";\nimport { center } from \"@turf/center\";\nimport { centroid } from \"@turf/centroid\";\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\nimport { rhumbDistance } from \"@turf/rhumb-distance\";\nimport { rhumbDestination } from \"@turf/rhumb-destination\";\nimport { coordEach, featureEach } from \"@turf/meta\";\nimport { point, isObject } from \"@turf/helpers\";\nimport { getCoord, getCoords, getType } from \"@turf/invariant\";\n\n/**\n * Scale GeoJSON objects from a given point by a scaling factor e.g. factor=2\n * would make each object 200% larger.\n * If a FeatureCollection is provided, the origin point will be calculated\n * based on each individual feature _unless_ an exact\n *\n * @function\n * @param {GeoJSON|GeometryCollection} geojson objects to be scaled\n * @param {number} factor of scaling, positive values greater than 0. Numbers between 0 and 1 will shrink the geojson, numbers greater than 1 will expand it, a factor of 1 will not change the geojson.\n * @param {Object} [options={}] Optional parameters\n * @param {Corners|Coord} [options.origin='centroid'] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance improvement if true)\n * @returns {GeoJSON|GeometryCollection} scaled GeoJSON\n * @example\n * const poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);\n * const scaledPoly = turf.transformScale(poly, 3);\n *\n * //addToMap\n * const addToMap = [poly, scaledPoly];\n * scaledPoly.properties = {stroke: '#F00', 'stroke-width': 4};\n */\nfunction transformScale<T extends GeoJSON | GeometryCollection>(\n  geojson: T,\n  factor: number,\n  options?: {\n    origin?: Corners | Coord;\n    mutate?: boolean;\n  }\n): T {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const origin = options.origin || \"centroid\";\n  const mutate = options.mutate || false;\n\n  // Input validation\n  if (!geojson) throw new Error(\"geojson required\");\n  if (typeof factor !== \"number\" || factor <= 0)\n    throw new Error(\"invalid factor\");\n  const originIsPoint = Array.isArray(origin) || typeof origin === \"object\";\n\n  // Clone geojson to avoid side effects\n  if (mutate !== true) geojson = clone(geojson);\n\n  // Scale each Feature separately if a feature collection AND the user didn't\n  // pass a single explicit point to scale the whole collection from.\n  if (geojson.type === \"FeatureCollection\" && !originIsPoint) {\n    featureEach(geojson, function (feature, index) {\n      // The type guard above is not recognised in the callback so we have to\n      // cast to accept responsibility.\n      (geojson as FeatureCollection).features[index] = scale(\n        feature,\n        factor,\n        origin\n      );\n    });\n    return geojson;\n  }\n  // Scale Feature/Geometry\n  return scale(geojson, factor, origin);\n}\n\n/**\n * Scale Feature/Geometry\n *\n * @private\n * @param {GeoJSON|GeometryCollection} feature feature or geometry collection to scale\n * @param {number} factor of scaling, positive or negative values greater than 0\n * @param {Corners|Coord} [origin=\"centroid\"] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\n * @returns {GeoJSON|GeometryCollection} scaled GeoJSON Feature/Geometry\n */\nfunction scale<T extends GeoJSON | GeometryCollection>(\n  feature: T,\n  factor: number,\n  origin: Corners | Coord\n): T {\n  // Default params\n  const isPoint = getType(feature) === \"Point\";\n  // Work with a Coord equivalent of the origin from here on.\n  const originCoord: Coord = defineOrigin(feature, origin);\n\n  // Shortcut no-scaling\n  if (factor === 1 || isPoint) return feature;\n\n  // Scale each coordinate\n  coordEach(feature, function (coord) {\n    const originalDistance = rhumbDistance(originCoord, coord);\n    const bearing = rhumbBearing(originCoord, coord);\n    const newDistance = originalDistance * factor;\n    const newCoord = getCoords(\n      rhumbDestination(originCoord, newDistance, bearing)\n    );\n    coord[0] = newCoord[0];\n    coord[1] = newCoord[1];\n    if (coord.length === 3) coord[2] *= factor;\n  });\n\n  delete feature.bbox;\n\n  return feature;\n}\n\n/**\n * Define Origin\n *\n * @private\n * @param {GeoJSON|GeometryCollection} geojson GeoJSON\n * @param {Corners|Coord} origin sw/se/nw/ne/center/centroid\n * @returns {Feature<Point>} Point origin\n */\nfunction defineOrigin(\n  geojson: GeoJSON | GeometryCollection,\n  origin: Corners | Coord\n): Coord {\n  // Default params\n  if (origin === undefined || origin === null) origin = \"centroid\";\n\n  // Input Coord\n  if (Array.isArray(origin) || typeof origin === \"object\")\n    return getCoord(origin);\n\n  // Define BBox\n  const bbox = geojson.bbox\n    ? geojson.bbox\n    : turfBBox(geojson, { recompute: true });\n  const west = bbox[0];\n  const south = bbox[1];\n  const east = bbox[2];\n  const north = bbox[3];\n\n  // Having to disable eslint below for lines which fail the no-fallthrough\n  // rule, though only because of the ts-expect-error rules. Once we remove\n  // southeast, bottomright, rightbottom, etc we should be able to remove all\n  // these supressions.\n  /* eslint-disable no-fallthrough */\n  switch (origin) {\n    case \"sw\":\n    // @ts-expect-error undocumented, to be removed for v8 #techdebt\n    case \"southwest\":\n    // @ts-expect-error undocumented, to be removed for v8 #techdebt\n    case \"westsouth\":\n    // @ts-expect-error undocumented, to be removed for v8 #techdebt\n    case \"bottomleft\":\n      return point([west, south]);\n    case \"se\":\n    // @ts-expect-error undocumented, to be removed for v8 #techdebt\n    case \"southeast\":\n    // @ts-expect-error undocumented, to be removed for v8 #techdebt\n    case \"eastsouth\":\n    // @ts-expect-error undocumented, to be removed for v8 #techdebt\n    case \"bottomright\":\n      return point([east, south]);\n    case \"nw\":\n    // @ts-expect-error undocumented, to be removed for v8 #techdebt\n    case \"northwest\":\n    // @ts-expect-error undocumented, to be removed for v8 #techdebt\n    case \"westnorth\":\n    // @ts-expect-error undocumented, to be removed for v8 #techdebt\n    case \"topleft\":\n      return point([west, north]);\n    case \"ne\":\n    // @ts-expect-error undocumented, to be removed for v8 #techdebt\n    case \"northeast\":\n    // @ts-expect-error undocumented, to be removed for v8 #techdebt\n    case \"eastnorth\":\n    // @ts-expect-error undocumented, to be removed for v8 #techdebt\n    case \"topright\":\n      return point([east, north]);\n    case \"center\":\n      return center(geojson);\n    case undefined:\n    case null:\n    case \"centroid\":\n      return centroid(geojson);\n    default:\n      throw new Error(\"invalid origin\");\n  }\n  /* eslint-enable no-fallthrough */\n}\n\nexport { transformScale };\nexport default transformScale;\n"]}